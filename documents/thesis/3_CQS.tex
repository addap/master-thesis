\section{Verifying Eio's Broadcast}
\label{sec:broadcast}

% <!-- In general, what is Broadcast/CQS? -->

In this section we describe the \emph{broadcast} data structure that Eio uses to implement of \emph{promises}.
Broadcasts are a customization of the recently developed \emph{CQS} data structure~\cite{koval2023cqs}.
CQS (for CancellableQueueSynchronizer) is a lock-free synchronization primitive that allows execution contexts to wait until signalled.
Its specification is already formally verified in Iris, so we were able to adapt the proofs to use them in our development.
CQS keeps the nature of an execution context abstract, but it is assumed that they support stopping execution and resuming with some value.
This is because CQS is designed to be used in the implementation of other synchronization constructs (e.g. mutex, barrier, promise, etc.) which take care of actually suspending and resuming execution contexts as required by their semantics.

% <!-- How does Eio use CQS?  -->

In the case of Eio an "execution context" is an Eio fiber.
CQS is multithreaded by design, so fibers can use the adapted broadcast functions to synchronize with fibers running in another thread.
In the following we describe the behavior of Eio's \emph{broadcast}, highlight differences to the \emph{original CQS}, and explain how we adapted the verification of the original CQS for our development.

\subsection{Operations of Broadcast}
\label{sec:broadcast-operations}

% <!-- What are the operations supported by the original CQS. -->

The original CQS supports three operations that are interesting to us: \emph{suspend}, \emph{resume}, and \emph{tryCancel}.
The equivalent operations in a broadcast are \emph{register}, \emph{signalAll}, and \emph{tryUnregister}, respectively.
While we established Eio's broadcast as an implementation of a signalling mechanism where fibers can register callbacks to be notified about events, the original formulation of CQS uses a more abstract future-based interface for the same purpose.

\paragraph*{suspend/register}
In the original CQS, an execution context that wants to wait for an event performs a suspend operation.
This operation creates and returns a new future that is used to stop execution because it is assumed that the language runtime supports suspending an execution context until a future is completed.
But Eio uses the broadcast data structure to \textbf{build} the runtime that allows its execution contexts (fibers) to suspend until an event happens (a promise is fulfilled).
So in the broadcast data structure, instead of returning a future, the register operation takes a callback as an additional argument and registers it to be called when the event happens.

\paragraph*{resume/signalAll}
As a dual to suspend, a resume operation in the original CQS completes a single registered future so that the language runtime resumes the associated execution context.
For broadcast, this is replaced by the signalAll operation, which invokes all callbacks that are registered with the data structure.
Eio uses signalAll instead of a signal operation that only invokes one callback in order to make the implementation of promises more straightforward.
When a promise is fulfilled, \textbf{all} fibers waiting on its value can continue execution, so the fine-grained control of a single signal operation is not needed.

\paragraph*{tryCancel/tryUnregister}
The semantics of the tryUnregister operation do not markedly change from the original.
A tryCancel operation can be used by an execution context to cancel the future returned by a suspend operation, so that the future is not completed by a call to resume.
Analogously, tryUnregister tries to undo the registration of a callback, so that it is not invoked in a call to signalAll.
The operation fails if a corresponding resume or signalAll happens first.

% % <!-- How to understand the operations?  -->
\paragraph*{}
To understand the broadcast operations better it is helpful to view them in the context in which they are used.
Like in the original CQS, an interaction with a broadcast is always guarded by first accessing an atomic variable that holds the state of the outer synchronization construct, in this case the state of the promise.
Since the whole data structure is lock-free, the atomic variable ensures that the operations have a synchronized view of the state.
For example, a register operation is only attempted if the promise is not fulfilled yet.
Figure~\ref{fig:cqs-usage} shows the possible interactions between fibers and a promise.
The calls to \ocamlin{Atomic.get} and \ocamlin{Atomic.set} happen in the functions \ocamlin{Promise.await} and \ocamlin{Promise.fulfill}, as shown in section~\ref{sec:sched-impl}.
If the promise is not fulfilled yet, \ocamlin{Promise.await} then performs a \esuspend{} effect and calls \ocamlin{Broadcast.register} and \ocamlin{Broadcast.try_unregister} if necessary.

\begin{figure}[ht]
  \includegraphics[width=\textwidth]{CQS_Outer_Atomic.png}
  \caption{Usage of broadcast in the context of a promise.}
  \label{fig:cqs-usage}
\end{figure}

Note that because it is lock-free and fibers can run on different threads, there can be a race between concurrent register, tryUnregister, and signalAll operations.
Possible interleavings and the necessity of the tryUnregister were explained in section~\ref{sec:sched-impl-await}.

\subsection{Implementation and Logical Interface of Broadcast}
\label{sec:broadcast-impl}

% <!-- Some general information how CQS is implemented and the logical state describing the entire queue. -->

Like the original CQS, broadcast is implemented as a linked list of arrays (called segments) that contain \emph{cells}\footnote{Using segments instead of single cells in the linked list is an optimization to amortize the linear runtime of linked list operations}.
There are two pointers pointing to the beginning and end of the active cell range, the signal pointer and the register pointer, and cells not reachable from either pointer are garbage collected.
There is a set of operations for manipulating the linked list and pointers to implement the higher-level functionality, but they are not part of the public API, so we do not focus on them.
Each cell is a container for one callback and the logical state of the broadcast tracks the current state of all existing cells.
The possible states for a single cell are shown in figure~\ref{fig:cqs-cell-states}, where the arrows are annotated with the operation that causes a state transition.

The state of a cell is initialized to \textbf{EMPTY} when it is reached by the register pointer\footnote{As opposed to the original CQS, in broadcast the signal pointer never overtakes the register pointer.}.
When a register and signalAll operation happen concurrently, they race to set the value of the empty cell.
If the signalAll operation wins, it writes a token value into the cell and the state becomes \textbf{SIGNALLED}.
The register operation can then read the token and invoke its callback directly.
The state is thus \textbf{INVOKED}.
If instead the register operation wins the race, it writes the callback into the cell, so the state takes the right path to \(\textbf{CALLBACK}_\textbf{waiting}\).
Then there can be another race between concurrent tryUnregister and signalAll operations.
Both try to overwrite the callback with a token value, which changes the state to \(\textbf{CALLBACK}_\textbf{invoked}\) or \(\textbf{CALLBACK}_\textbf{unregistered}\), respectively, depending on the winner.

\begin{figure}[ht]
  \includegraphics[width=\textwidth]{Cell_States.png}
  \caption{State transition diagram for a single cell.}
  \label{fig:cqs-cell-states}
\end{figure}

\subsection{Verification of Broadcast}
\label{sec:broadcast-spec}

In the following we describe the specifications we proved for the functions implemented in Eio's \ocamlin{Broadcast} module.
Note that all specifications obey the empty protocol because the code does not perform any effects.
For all three operations, the Eio implementation and specification differs from what is already verified in the original CQS (e.g. due to some reordered instructions or a different control flow).
However, the specifications of the underlying operations for manipulating cell pointers are modular enough to allow us to prove the new specifications for \ocamlin{Broadcast.create}, \ocamlin{Broadcast.register}, and \ocamlin{Broadcast.try_unregister}.

As for \ocamlin{Broadcast.signal_all}, Eio implements this function by atomically increasing the signal pointer by the number \(n\) of registered callbacks and then processing all \(n\) cells between the old and new pointer position.
Because of technical differences in handling these pointers between the original CQS implementation of the paper~\cite{koval2023cqs} and the broadcast implementation of Eio we opted to verify a different implementation of \ocamlin{Broadcast.signal_all}, that increments the signal pointer \(n\) times in a loop.
We argue this does not change the observable behaviors of the function since we ensure that it can only be called once.

\subsubsection{\ocamlin{Broadcast.create}}
\label{sec:broadcast-spec-create}

The only precondition to create a new broadcast is the proposition \(inv\_heap\_inv\).
This is a piece of ghost state defined by the Iris standard library that models invariant locations, which are locations that can always be read.
That means they cannot be explicitly deallocated and can only exist in a garbage-collected setting, like \ocf{}.
The implementation of the linked list uses this internally.

The function returns a broadcast instance \(bcst\), along with the persistent \(\gsIsBcst{}\; bcst\) proposition that shows the value actually is a broadcast.
We also obtain the unique resource \gssignal{}, which is held by the enclosing promise and allows calling the \ocamlin{Broadcast.signal_all} function once.

\[
  \inferrule[Spec-BroadcastCreate]
  {inv\_heap\_inv}
  {\ewp{create\; ()}{\bot}{bcst.\; \gsIsBcst{}\; bcst \ast \gssignal{}}}
\]

\subsubsection{\ocamlin{Broadcast.register}}
\label{sec:broadcast-spec-suspend}

% For a \emph{register} operation the \emph{suspend permit} from the original CQS is not needed anymore since we do the \emph{enqueue registration} internally.
A register operation takes a callback \(cb\) and the associated resource \(\gsIsCb{}\; cb\; R\) which represents the permission to invoke the callback.
We instantiate \(R\) with \gspdone{\gamma} so that the callback transports the knowledge that the promise has been fulfilled.
\(\gsIsCb{}\) is not persistent because the callback must be invoked only once.

\begin{align*}
  \gsIsCb{}\; cb\; R                            & \triangleq R \wand \ewp{cb\; ()}{\bot}{\top}                                                           \\
  \emph{isBroadcastRegisterResult}\; r\; cb\; R & \triangleq \begin{aligned}[t]
                                                  & (\ulcorner r = Invoked \urcorner)                                                           \\
                                                \vee\; & (\ulcorner r = Registered\; h \urcorner \ast \emph{isBroadcastRegisterHandle}\; h\; cb\; R) 
                                                \end{aligned}\\
  \emph{isBroadcastRegisterHandle}              & : Val \to Val \to iProp \to iProp
\end{align*}

The \ocamlin{Broadcast.register} function tries to insert a callback into the next cell designated by the register pointer.
If it succeeds the function returns a \ocamlin{Registered handle} value that can be used by \ocamlin{Broadcast.try_unregister}.
But if the cell is already in the \textbf{SIGNALLED} state, the function immediately invokes the callback and returns a \ocamlin{Invoked} value.

\[
  \inferrule[Spec-BroadcastRegister]
  { \gsIsBcst{}\; bcst \ast \gsIsCb{}\; callback\; R }
  { \ewp{register\; bcst\; callback}{\bot}{r.\; \emph{isBroadcastRegisterResult}\; r\; callback\; R}}
\]

\subsubsection{\ocamlin{Broadcast.try_unregister}}
\label{sec:broadcast-spec-cance}

Given a handle and its \(\textit{isBroadcastRegisterHandle}\; h\; cb\; R\) resource, \ocamlin{Broadcast.try_unregister} tries to cancel the registration of the callback.

If the callback had already been invoked by \ocamlin{Broadcast.signal_all} (i.e. the state is \(\textbf{CALLBACK}_\textbf{invoked}\)) the function returns \ocamlin{false} and no resources are returned to the caller.
Otherwise, the permission to invoke the callback \(\gsIsCb{}\; cb\) is returned.

\[
  \inferrule[Spec-BroadcastTryCancel]
  { \emph{isBroadcastRegisterHandle}\; h\; cb\; R }
  { \ewp{try\_unregister\; h}{\bot}{b.\; if\; b\; then\; \gsIsCb{}\; cb\; R\; else\; \top}}
\]

\subsubsection{\ocamlin{Broadcast.signal_all}}
\label{sec:broadcast-spec-signal-all}

To call \ocamlin{Broadcast.signal_all} the unique \(\gssignal{}\) resource is needed, along with a duplicable \(R\), so that it can be used to invoke multiple callbacks.
The function does not return any resources because its only effect is making an unknown number of fibers resume execution, which we cannot easily formalize in Iris.

\[
  \inferrule[Spec-BroadcastSignalAll]
  { \gsIsBcst{}\; bcst \ast \always R \ast \gssignal{}}
  { \ewp{signalAll\; bcst}{\bot}{\top} }
\]

\subsection{Changes from the Original CQS}
\label{sec:broadcast-spec-removed-features}

The original CQS supports multiple additional features like a synchronous mode for suspend and resume, and also a smart cancellation mode.
These features enlarge the state space of CQS and complicate the verification but are not used in Eio so when we ported the verification of CQS to our Eio development we removed support for these features.
This reduced the state space of a cell shown in figure~\ref{fig:cqs-cell-states-original} to a more manageable size when adapting the proofs.

\begin{figure}[ht]
  \includegraphics[width=\textwidth]{Cell_States_Original.png}
  \caption{Cell states in the original CQS from~\cite{koval2023cqs} (page 42).}
  \label{fig:cqs-cell-states-original}
\end{figure}

The part of the verification of the original CQS that we had to customize for Eio was originally 3600 lines of Coq code but -- due to these simplifications -- we could reduce it by approximately 1300 lines of Coq code.
Additionally, there are ~4000 lines of Coq code about lower-level functionality that we did not need to adapt when porting them to our development.

% The number of active cells \(n\) (i.e. the length of the queue) is tracked by the logical resource \(CQSState\; n\).
% In normal usage of CQS, the atomic variable of the outer synchronization construct would encode the length of the queue in its value and keep this resource in an associated invariant.
% Changing the length of the queue is done using \emph{enqueue} and \emph{dequeue registration} logical operations when opening this invariant.

% However, for promises the exact length of the queue is irrelevant because the \emph{signalAll} operation will always set the length to 0.
% So in the adapted proof for Eio's broadcast we keep the \(CQSState\; n\) resource in the invariant of the broadcast itself.
% As a consequence we also move the \emph{enqueue} and \emph{dequeue registration} out of the public logical API because they are now done internally.

