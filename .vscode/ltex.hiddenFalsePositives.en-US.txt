{"rule":"LC_AFTER_PERIOD","sentence":"^\\QIn the Promise.await function if the promise is not fulfilled initially the fiber should wait until that is the case so it performs a effect.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QFrom the point of view of the fiber, the polymorphic type 'a of the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q effect is instantiated depending on how the effect's return value is used.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q[PS-Contra] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q Logical Rules for the PromiseState Resource.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\Q[PS-Create] .\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q[PS-Contra] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q Rules for the PromiseState Resource.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QMaybe use metatokens to hide gamma\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QThe specification Spec-ForkPromise expresses that we can give the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q function an arbitrary expression \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q that must be callable on unit, obeys the protocol and returns some value \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QThe specification Spec-ForkPromise expresses that we can give the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q function an arbitrary expression \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q that, when called, obeys the protocol and returns some value \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q satisfying \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QThe specification Spec-Await is the direct counterpart to Spec-ForkPromise.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QAs the Spec-MakeRegister specification shows, it returns a suitable function that satisfies the predicate, instantiating \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q such that we receive a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q resource when the effect returns.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q[Spec-MakeRegister] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q p cqs makeregister p cqs  reg, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q reg ( v, v = () \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q)\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\Q[Spec-MakeRegister] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q p cqs makeregister p cqs  reg, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q reg ( v, v = () \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q)\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\Q[Spec-MakeRegister] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q p cqs makeregister p cqs  reg, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q reg ( v, v = () \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q)\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\Q[Spec-Await] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q p await p  v, v\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q[Spec-CQSTryCancel] isCQSRegisterHandle h callback R CQS.trycancel h  b, if b then callback R else\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\Q[Spec-CQSTryCancel] isCQSRegisterHandle h callback R CQS.trycancel h  b, if b then callback R else\\E$"}
{"rule":"COMMA_COMPOUND_SENTENCE","sentence":"^\\QThe CQS specification is already verified using Iris, but Eio uses a custom implementation for which we had to adapt the proof and we discuss this process in section \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"A_INFINITIVE","sentence":"^\\QCQS is implemented as a queue of cells with two pointers pointing to the beginning and end of the active cell range, the suspend pointer and the resume pointer.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QThe original CQS supports three operations that are interesting to us: suspend, tryCancel, and resume.\\E$"}
{"rule":"A_INFINITIVE","sentence":"^\\QThe Broadcast.register function will advance the suspend pointer to allocate a fresh cell in the EMPTY logical state.\\E$"}
{"rule":"A_INFINITIVE","sentence":"^\\QFor a register operation the suspend permit from the original CQS is not needed anymore since we do the enqueue registration internally.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QIn figures \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q we give Hoare-style proof annotations for the two functions make_register and Promise.await from figure \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"TO_NON_BASE","sentence":"^\\QIf the signalAll operation wins, it writes a token value into the cell which changes the logical state to SIGNALLED.\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\QTherefore, deriving a weakest precondition for an expression \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q proves its specification in terms of the assumptions \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and conclusion \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"MISSING_GENITIVE","sentence":"^\\QHoare triples are even defined this way in Iris: \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q Since propositions are affine by default, the persistence modality \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is used to define Hoare triples as persistent.\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\QTherefore, deriving a weakest precondition for an expression \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q proves a specification for it in terms of the assumptions \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and conclusion \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"ARROWS","sentence":"^\\QIt would be equally valid to push the closure (fun () -> execute fiber) into the run queue instead, to give priority to the already running fiber.\\E$"}
{"rule":"IN_A_X_MANNER","sentence":"^\\QThe library uses the new effect handler feature from \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q to implement fibers in an efficient way without stack copying \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\QThe last step in proving the program specification consists of deriving a (partial) weakest precondition \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q for the program expression \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QIn figures \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q we give Hoare-style proof annotations for the two functions \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
