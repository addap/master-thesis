{"rule":"LC_AFTER_PERIOD","sentence":"^\\QIn the Promise.await function if the promise is not fulfilled initially the fiber should wait until that is the case so it performs a effect.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QFrom the point of view of the fiber, the polymorphic type 'a of the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q effect is instantiated depending on how the effect's return value is used.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q[PS-Contra] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q Logical Rules for the PromiseState Resource.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\Q[PS-Create] .\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q[PS-Contra] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q Rules for the PromiseState Resource.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QMaybe use metatokens to hide gamma\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QThe specification Spec-ForkPromise expresses that we can give the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q function an arbitrary expression \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q that must be callable on unit, obeys the protocol and returns some value \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QThe specification Spec-ForkPromise expresses that we can give the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q function an arbitrary expression \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q that, when called, obeys the protocol and returns some value \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q satisfying \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QThe specification Spec-Await is the direct counterpart to Spec-ForkPromise.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QAs the Spec-MakeRegister specification shows, it returns a suitable function that satisfies the predicate, instantiating \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q such that we receive a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q resource when the effect returns.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q[Spec-MakeRegister] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q p cqs makeregister p cqs  reg, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q reg ( v, v = () \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q)\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\Q[Spec-MakeRegister] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q p cqs makeregister p cqs  reg, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q reg ( v, v = () \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q)\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\Q[Spec-MakeRegister] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q p cqs makeregister p cqs  reg, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q reg ( v, v = () \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q)\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\Q[Spec-Await] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q p await p  v, v\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q[Spec-CQSTryCancel] isCQSRegisterHandle h callback R CQS.trycancel h  b, if b then callback R else\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\Q[Spec-CQSTryCancel] isCQSRegisterHandle h callback R CQS.trycancel h  b, if b then callback R else\\E$"}
{"rule":"COMMA_COMPOUND_SENTENCE","sentence":"^\\QThe CQS specification is already verified using Iris, but Eio uses a custom implementation for which we had to adapt the proof and we discuss this process in section \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"A_INFINITIVE","sentence":"^\\QCQS is implemented as a queue of cells with two pointers pointing to the beginning and end of the active cell range, the suspend pointer and the resume pointer.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QThe original CQS supports three operations that are interesting to us: suspend, tryCancel, and resume.\\E$"}
{"rule":"A_INFINITIVE","sentence":"^\\QThe Broadcast.register function will advance the suspend pointer to allocate a fresh cell in the EMPTY logical state.\\E$"}
{"rule":"A_INFINITIVE","sentence":"^\\QFor a register operation the suspend permit from the original CQS is not needed anymore since we do the enqueue registration internally.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QIn figures \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q we give Hoare-style proof annotations for the two functions make_register and Promise.await from figure \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"TO_NON_BASE","sentence":"^\\QIf the signalAll operation wins, it writes a token value into the cell which changes the logical state to SIGNALLED.\\E$"}
